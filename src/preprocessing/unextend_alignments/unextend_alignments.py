import sys, getopt

class Alignment(object):
	'''
	Takes as input lines from a MAF file and computes a new alignment for
	unextended regions of the reads only.
	'''
	def __init__(self, refLine, uReadLine, cReadLine):
		'''
		Inputs
		- (string) refLine: directly from MAF file
		- (string) uReadLine: ditto
		- (string) cReadLine: ditto
		'''	
		refLine = refLine.split()
		self.strand = refLine[4]
		self.srcSize = int(refLine[5])
		ref = refLine[6]
		
		uReadLine = uReadLine.split()
		readName = uReadLine[1]
		self.readNumber = int( re.findall('(\d+)', uRead)[readNumberIndex_g] )
		uRead = uReadLine[6]

		cReadLine = cReadLine.split()
		cRead = cReadLine[6]

		assert len(cRead) == len(uRead)

		# Used to update the starting point where the reads align in the
		# reference
		lengthBeforeRemoval = len(cRead)

		# First remove extended prefixes by reversing the strings
		ref, uRead, cRead = reverseReads(ref, uRead, cRead)
		ref, uRead, cRead = removeExtendedSuffix(ref, uRead, cRead)

		# Reverse the string to get it back to normal 
		ref, uRead, cRead = reverseReads(ref, uRead, cRead)

		# Update the starting point where the reads align in the reference
		lengthAfterRemoval = len(cRead)
		difference = lengthBeforeRemoval - lengthAfterRemoval
		oldStart = cReadLine[2]		
		self.start = oldStart + difference

		# Remove extended suffix of ref, uRead and cRead and store result
		self.ref, self.uRead, self.cRead = removeExtendedSuffix(ref, uRead, cRead)

	def getReadNumber():
		'''
		Returns the read number of the alignments.
		'''
		return self.readNumber

	def getStrand():
		'''
		Returns '+' or '-' to indicate whether the alignment 
		is to the original ('+') or reverse-complemented ('-') source
		'''
		return self.strand

	def getSrcSize():
		'''
		Returns the size of the original reference genome.
		'''
		return self.srcSize

	def getStart():
		'''
		Returns the start of the aligning region in the source sequence.
		'''
		return self.start

	def getRefSize():
		'''
		Returns the number of non-'-' characters in the reference alignment
		'''
		return sizeOfSequence(self.ref)

	def getUncorrectedSize():
		'''
		Returns the number of non-'-' characters in the uncorrected alignment
		'''
		return sizeOfSequence(self.uRead)

	def getCorrectedSize():
		'''
		Returns the number of non-'-' characters in the corrected alignment
		'''
		return sizeOfSequence(self.uRead)

	def getRef():
		'''
		Get the truncated reference alignment with extended prefix and suffix removed.
		'''
		return self.ref

	def getUncorrectedRead():
		'''
		Get the truncated uncorrected read alignment with extended prefix and suffix removed.
		'''
		return self.uRead

	def getCorrectedRead():	
		'''
		Get the truncated corrected read alignment with extended prefix and suffix removed.
		'''
		return self.cRead

	def removeExtendedSuffix(ref, uRead, cRead): 
		# Trim off trailing '-'
		lengthBeforeStrip = len(ref)

		ref = ref.rstrip('-')
		lengthAfterStrip = len(ref)

		lengthDifference = lengthBeforeStrip - lengthAfterStrip
		
		newEndIndex = len(cRead) - lengthDifference
		cRead = cRead[0:newEndIndex]
		uRead = uRead[0:newEndIndex]

		assert len(ref) == len(cRead)

		return ref, uRead, cRead

	def reverseReads(ref, uRead, cRead):
		# Reverse the reads
		ref = ref[::-1]
		uRead = uRead[::-1]
		cRead = cRead[::-1]
		return ref, cRead, uRead

	def sizeOfSequence(read):
		# Returns the number of all non-'-' characters in read
		read = read.replace('-', '')
		return len(read)

def readInput(mafInputPath):
	'''
	Read and store the alignments from the three-way MAF file.
	Input
	- (string) mafInputPath: the path to the three-way MAF file generated by lrcstats
	Output
	- (list of Alignment objects) alignments
	'''
	with open(mafInputPath, 'r') as file:
		alignments = []
		for line in file:
			line = line.split()
			if len(line) > 0 and line[0] != "#":
				if line[0] == 'a':
					if None not in [refLine, uReadLine, cReadLine]:
						alignment = Alignment(refLine, uReadLine, cReadLine)
						alignments.append( alignment )
					refLine = None
					uReadLine = None
					cReadLine = None
				elif refLine is None:
					refLine = line
				elif uReadLine is None:
					uReadLine = None
				elif cReadLine is None:
					cReadLine = None
	return alignments

def writeUnextended(outputPath, alignments):
	'''
	Write the unextended alignments into new MAF file
	Inputs
	- (string) outputPath: absolute path to the output file
	- (list of Alignment objects): contains the unextended alignments
	'''	
	with open(outputPath,'w') as file:
		file.write("##maf version=1\n")
		for alignment in alignments:
			file.write("a\n")
			
			readNumber = alignment.getReadNumber()
			start = alignment.getStart()	
			strand = alignment.getStrand()
			srcSize = alignment.getSrcSize()

			refSrc = "%d.reference" % (readNumber)
			refSize = alignment.getRefSize()
			ref = alignment.getRef()

			refLine = "s %s %d %d %s %d %s\n" % (refSrc, start, refSize, strand, srcSize, ref) 
			file.write(refLine)
			
			uReadSrc = "%d.uncorrected" % (readNumber)
			uReadSize = alignment.getUncorrectedSize()
			uRead = alignment.getUncorrectedRead()

			uReadLine = "s %s %d %d %s %d %s\n" % (uReadSrc, start, uReadSize, strand, srcSize, uRead) 
			file.write(uReadLine)

			cReadSrc = "%d.corrected" % (readNumber)
			cReadSize = alignment.getCorrectedSize()
			cRead = alignment.getCorrectedRead()

			cReadLine = "s %s %d %d %s %d %s\n" % (cReadSrc, start, cReadSize, strand, srcSize, cRead) 
			file.write(cReadLine)
			file.write('\n')

helpMessage = "Reads three-way alignment MAF files and outputs another three-way MAF file without extended segments on reads and a second MAF file with only alignment between the reference and the extended segment of the read."
usageMessage = "[-h help and usage] [-i three-way MAF file] [-r reference FASTA] [-m unextended MAF output path] [-e extension segments MAF output path] [-p used PBSim]"

options = "hi:r:m:e:"

try:
	opts, args = getopt.getopt(sys.argv[1:], options)
except getopt.GetoptError:
	print "Error: unable to read command line arguments."
	sys.exit(2)

if len(sys.argv) == 1:
	print usageMessage
	sys.exit(2)

mafInputPath = None
refPath = None
unextendedPath = None
extensionPath = None
usedPbsim = False

for opt, arg in opts:
	if opt == '-h':
		print helpMessage
		print usageMessage
		sys.exit()
	elif opt == '-i':
		mafInputPath = arg
	elif opt == '-r':
		refPath = arg
	elif opt == '-m':
		unextendedPath = arg
	elif opt == '-e':
		extensionPath = True
	elif opt == '-p':
		usedPbsim = True

if not usedPbsim:
	readNumberIndex_g = 1
else:
	readNumberIndex_g = 0

if mafInputPath is None or refPath is None or unextendedPath is None or extensionPath is None:
	print "Missing argument - please double check your command."
	sys.exit(2)

alignments = readInput( mafInputPath )
writeUnextended(unextendedAlignments)
